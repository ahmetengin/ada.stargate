
# üöÄ Ada Stargate v4.0: The "Big 3" Architecture Migration

**Reference Philosophy:** [Big 3 Super Agent](https://github.com/disler/big-3-super-agent) | [Beyond MCP](https://github.com/disler/beyond-mcp) | [Advanced Tool Use](https://www.anthropic.com/engineering/advanced-tool-use)

## 1. The Core Shift
We are transitioning from a **Monolithic Frontend Orchestrator** (current React App) to a **Federated Multi-Agent Backend** (Python/FastAPI).

The goal is **"Zero Error"** via specialized agents running in isolated environments (Sandboxes), communicating via a strictly typed protocol (MCP) and orchestrating via Code.

---

## 2. The "Big 3" Hierarchy for Ada

### üß† Level 1: The ORCHESTRATOR (Router & Discovery)
*   **Identity:** `ada.marina.wim`
*   **Technology:** **LangGraph** + **Tool Search**
*   **Role:** The "State Machine". It does not perform tasks. It maintains the *Global Context*.
*   **Advanced Pattern (Tool Search):**
    *   Instead of loading 50+ tools (Finance, Legal, Sea) into the context, the Orchestrator uses a **Discovery Tool**.
    *   *Flow:* User asks about "Invoice" -> Orchestrator searches tools -> Loads `ada.finance` toolset -> Routes request.

### üëî Level 2: The EXPERTS (MCP Servers)
*   **Identity:** `ada.finance`, `ada.legal`, `ada.technic`, `ada.sea`
*   **Technology:** **FastMCP** (Python)
*   **Role:** Domain Experts. They expose "Tools" to the Orchestrator but possess their own internal reasoning loops.
*   **Architecture:** Each Expert is an independent MCP Server.
    *   *Benefit:* `ada.finance` can crash without killing `ada.legal`.
    *   *Benefit:* `ada.legal` cannot hallucinate financial data because it has no access to that database.

### üõ†Ô∏è Level 3: The WORKERS (Programmatic Execution)
*   **Identity:** "Code Interpreter", "Analysis Bot", "Scraper"
*   **Technology:** **Programmatic Tool Calling (PTC)** + **Pydantic AI**
*   **Role:** The "Hands". They execute code generated by the Experts.
*   **Pattern:** **"Code-First"**.
    *   Instead of the LLM requesting tools one by one (Chat Loop), it writes a **Python Script** to orchestrate the tools.
    *   *Example:* `ada.finance` writes a script that calls `get_invoice_items()`, sums them up using Python math (Zero Error), applies VAT, and calls `generate_pdf()`. The LLM only sees the final result.

---

## 3. Tech Stack Mapping (Current vs Future)

| Component | Current (v3.2 - Typescript) | Future (v4.0 - Python Enterprise) |
| :--- | :--- | :--- |
| **Orchestrator** | `orchestratorService.ts` (Regex/If-Else) | **LangGraph** (Stateful Graph) |
| **Discovery** | Hardcoded Imports | **Tool Search Tool** (Dynamic Loading) |
| **Agents** | `services/agents/*.ts` (In-memory objects) | **FastMCP Servers** (Independent Processes) |
| **Execution** | Browser JS Engine | **Programmatic Tool Calling** (Sandboxed Python) |
| **Memory** | React State (Transient) | **PostgreSQL** (Entity) + **Redis** (State) |

---

## 4. Migration Strategy: "Strangler Fig" Pattern

We will not delete the frontend. We will replace the internals piece by piece.

**Phase 1: The Bridge**
1.  Spin up a **FastAPI** server.
2.  Create the first **FastMCP** server for `ada.finance`.
3.  Modify `financeAgent.ts` in React to stop calculating locally and instead call `POST /api/finance/invoice`.

**Phase 2: The Brain Transplant**
1.  Implement **LangGraph** on the backend.
2.  Point the React Chat Interface to stream responses from LangGraph.

**Phase 3: Full Autonomy**
1.  Deploy **Qdrant** for `ada.legal`.
2.  Enable **Programmatic Execution** (The Expert writes code to solve complex problems).

---

## 5. Why this achieves "Zero Error"?
1.  **Type Safety:** Pydantic ensures input/output is exactly what is expected.
2.  **Code Execution:** Mathematical and logical tasks are solved by Python code, not LLM probability tokens.
3.  **Isolation:** Errors are contained within a single node/sandbox and retried automatically.
